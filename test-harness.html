<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Paper Wings! – Тестовый стенд</title>
  <link rel="stylesheet" href="styles.css" />
  <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Roboto&display=swap" rel="stylesheet">
  <style>
    body.test-harness {
      position: relative;
      background: radial-gradient(circle at top, #1a2338 0%, #0c1220 60%, #070b15 100%);
      color: #f5f7ff;
      overflow: auto;
      touch-action: auto;
      min-height: 100vh;
      padding: 0;
    }

    .harness-stage {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .harness-stage > * {
      pointer-events: auto;
    }

    .harness-panel {
      position: fixed;
      top: 16px;
      bottom: 16px;
      width: 280px;
      padding: 16px 18px 20px;
      overflow-y: auto;
      background: rgba(12, 18, 32, 0.92);
      border: 1px solid rgba(94, 154, 255, 0.25);
      border-radius: 16px;
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
      color: #f5f7ff;
      z-index: 1500;
      backdrop-filter: blur(4px);
    }

    .harness-panel h1 {
      margin: 0 0 18px;
      font-size: 1.4rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9ab4ff;
    }

    .harness-panel h2,
    .harness-panel h3 {
      margin: 12px 0 8px;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #b6c6ff;
    }

    .harness-panel p,
    .harness-panel label,
    .harness-panel dt,
    .harness-panel dd {
      font-size: 0.88rem;
      line-height: 1.4;
    }

    .harness-panel small {
      color: #8ea0d8;
      font-size: 0.78rem;
    }

    .harness-panel--left {
      left: 16px;
    }

    .harness-panel--right {
      right: 16px;
    }

    .harness-section {
      margin-bottom: 20px;
      border-top: 1px solid rgba(94, 154, 255, 0.18);
      padding-top: 14px;
    }

    .harness-section:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    .test-harness .test-controls {
      position: static;
      top: auto;
      right: auto;
      left: auto;
      width: 100%;
      max-width: none;
      z-index: auto;
      background: rgba(20, 27, 46, 0.82);
      box-shadow: inset 0 0 0 1px rgba(94, 154, 255, 0.25);
      backdrop-filter: none;
    }

    .test-harness .test-controls__toggle {
      border-radius: 12px 12px 0 0;
      background: linear-gradient(135deg, rgba(54, 98, 180, 0.9), rgba(35, 64, 120, 0.9));
    }

    .test-harness .test-controls__body {
      padding: 14px;
      background: transparent;
    }

    .test-harness .test-controls__actions button {
      background: rgba(255, 255, 255, 0.18);
    }

    .harness-button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
    }

    .harness-button-group button,
    .harness-panel button {
      flex: 1 1 calc(50% - 4px);
      padding: 8px 10px;
      font-size: 0.85rem;
      border-radius: 10px;
      border: 1px solid rgba(129, 170, 255, 0.4);
      background: linear-gradient(135deg, rgba(32, 54, 96, 0.75), rgba(21, 33, 61, 0.75));
      color: #f5f7ff;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.15s ease, box-shadow 0.15s ease;
    }

    .harness-panel button:hover {
      background: linear-gradient(135deg, rgba(51, 80, 138, 0.9), rgba(27, 44, 81, 0.9));
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
    }

    .harness-panel button:active {
      transform: translateY(1px);
    }

    .harness-panel button.full-width {
      flex: 1 1 100%;
    }

    .harness-panel input,
    .harness-panel select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(129, 170, 255, 0.35);
      background: rgba(9, 14, 27, 0.9);
      color: #f5f7ff;
      font-size: 0.85rem;
      margin-bottom: 8px;
    }

    .harness-panel select:disabled,
    .harness-panel button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 12px;
      margin: 0;
      padding: 0;
    }

    .status-grid dt {
      margin: 0;
      color: #8ea0d8;
      font-weight: 600;
    }

    .status-grid dd {
      margin: 0;
    }

    .plane-details {
      background: rgba(7, 11, 22, 0.8);
      border: 1px solid rgba(129, 170, 255, 0.25);
      border-radius: 12px;
      padding: 10px 12px;
      margin-top: 8px;
      font-size: 0.82rem;
      line-height: 1.45;
    }

    .plane-details strong {
      color: #d6e0ff;
    }

    .harness-note {
      margin: 0;
      font-size: 0.78rem;
      color: #8095d5;
    }

    .inspector-overlay {
      position: absolute;
      inset: 0;
      z-index: 500;
      pointer-events: none;
      font-family: 'Roboto', sans-serif;
      display: none;
    }

    .inspector-overlay__svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .inspector-overlay__crosshair {
      stroke: rgba(94, 154, 255, 0.65);
      stroke-width: 1.5;
      vector-effect: non-scaling-stroke;
      display: none;
    }

    .inspector-overlay__ruler-line {
      stroke: rgba(255, 204, 102, 0.9);
      stroke-width: 2;
      stroke-dasharray: 6 4;
      vector-effect: non-scaling-stroke;
      display: none;
    }

    .inspector-overlay__point {
      fill: rgba(255, 204, 102, 0.95);
      stroke: rgba(12, 18, 32, 0.85);
      stroke-width: 1.6;
      vector-effect: non-scaling-stroke;
      display: none;
    }

    .inspector-overlay__tooltip {
      position: absolute;
      left: 0;
      top: 0;
      transform: translate(-9999px, -9999px);
      pointer-events: none;
      display: none;
    }

    .inspector-overlay__tooltip-content {
      background: rgba(9, 15, 28, 0.88);
      border: 1px solid rgba(129, 170, 255, 0.4);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.4);
      padding: 8px 10px;
      color: #f5f7ff;
      min-width: 180px;
      max-width: 240px;
    }

    .inspector-overlay__row {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 0.78rem;
      line-height: 1.35;
    }

    .inspector-overlay__row + .inspector-overlay__row {
      margin-top: 6px;
    }

    .inspector-overlay__row strong {
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #9ab4ff;
    }

    .inspector-overlay__value {
      white-space: pre-line;
      font-size: 0.82rem;
      font-weight: 500;
      color: #f5f7ff;
    }

    .inspector-status {
      grid-template-columns: minmax(0, 1fr);
      gap: 6px;
      margin-top: 12px;
    }

    .inspector-status dd {
      white-space: normal;
      word-break: break-word;
    }

    @media (max-width: 1280px) {
      .harness-panel {
        width: 240px;
      }
    }

    @media (max-width: 1100px) {
      .harness-panel--left,
      .harness-panel--right {
        position: static;
        width: auto;
        margin: 12px 16px;
      }

      .harness-stage {
        flex-direction: column;
        padding-top: 12px;
      }
    }
  </style>
</head>
<body class="test-harness">
  <aside class="harness-panel harness-panel--left" aria-label="Панель управления режимами">
    <h1>Test Harness</h1>

    <div class="harness-section" aria-labelledby="flowTitle">
      <h2 id="flowTitle">Управление раундами</h2>
      <div class="harness-button-group">
        <button id="resetGameBtn" class="full-width">Полный сброс</button>
        <button id="startRoundBtn" class="full-width">Старт нового раунда</button>
        <button id="startLoopBtn">Запуск цикла</button>
        <button id="stopLoopBtn">Стоп цикла</button>
        <button id="showMenuBtn">Показать меню</button>
        <button id="hideMenuBtn">Спрятать меню</button>
      </div>
      <div class="harness-button-group">
        <button id="forceGreenWinBtn">Победа зелёных</button>
        <button id="forceBlueWinBtn">Победа синих</button>
        <button id="showEndScreenBtn">Показать энд-скрин</button>
        <button id="hideEndScreenBtn">Скрыть энд-скрин</button>
      </div>
      <div class="harness-button-group">
        <button id="lockRoundWinBtn" class="full-width" title="Завершить раунд без показа финального экрана">Завершить раунд (без энд-скрина)</button>
        <button id="lockGameWinBtn" class="full-width" title="Завершить игру с показом финального экрана">Завершить игру (с энд-скрином)</button>
      </div>
      <small>Используйте кнопки для отладки смены фаз, меню и сценариев конца раунда или всей игры.</small>
    </div>

    <div class="harness-section" aria-labelledby="settingsTitle">
      <h2 id="settingsTitle">Настройки карты</h2>
      <div class="harness-button-group">
        <button id="toggleAAButton">ПВО: выкл.</button>
        <button id="toggleEdgesButton">Контуры: выкл.</button>
        <button id="nextMapButton" class="full-width">Следующая карта</button>
      </div>
      <small>Переключение настроек сразу пересоздаёт раунд для применения.</small>
    </div>

    <div class="harness-section harness-section--test-controls" aria-labelledby="testControlsHeading">
      <h2 id="testControlsHeading">Расширенные настройки</h2>
      <div id="testControlPanel" class="test-controls collapsed" aria-live="polite">
        <button id="testControlsToggle" class="test-controls__toggle" aria-expanded="false" type="button">
          Test Controls
        </button>
        <div class="test-controls__body" id="testControlsBody">
          <div class="test-controls__field">
            <label for="inGameMapSelect" class="test-controls__label">Map</label>
            <select id="inGameMapSelect" class="test-controls__select"></select>
          </div>
          <div class="test-controls__field">
            <label for="inGameFlameStyle" class="test-controls__label">Flame Style</label>
            <select id="inGameFlameStyle" class="test-controls__select"></select>
          </div>
          <div class="test-controls__field">
            <label for="testFlightRange" class="test-controls__label">Flight Range (cells)</label>
            <input id="testFlightRange" class="test-controls__input" type="number" min="5" max="30" step="1" inputmode="numeric" />
          </div>
          <div class="test-controls__field">
            <label for="testAmplitude" class="test-controls__label">Aiming Amplitude (°)</label>
            <input id="testAmplitude" class="test-controls__input" type="number" min="0" max="120" step="1" inputmode="decimal" />
          </div>
          <label class="test-controls__checkbox">
            <input type="checkbox" id="testAddAAToggle" />
            <span>Include AA placement phase</span>
          </label>
          <label class="test-controls__checkbox">
            <input type="checkbox" id="testSharpEdgesToggle" />
            <span>Enable sharp arena edges</span>
          </label>
          <label class="test-controls__checkbox">
            <input type="checkbox" id="testRandomizeToggle" />
            <span>Randomize map each round</span>
          </label>
          <div class="test-controls__actions">
            <button id="testApplyBtn" type="button">Apply</button>
            <button id="testRestartBtn" type="button">Apply &amp; Restart</button>
          </div>
        </div>
      </div>
    </div>
  </aside>

  <div class="harness-stage">
    <div id="gameContainer">
      <div class="game-wrap">
        <canvas id="gameCanvas" width="360" height="640" style="display:none;"></canvas>
      </div>

      <div id="greenScoreCounter" class="score-counter score-counter--green" aria-hidden="true"></div>
      <div id="blueScoreCounter" class="score-counter score-counter--blue" aria-hidden="true"></div>

      <div id="hudPlaneStyleProbes" aria-hidden="true"
           style="position:absolute;width:0;height:0;overflow:hidden;clip-path:inset(50%);">
        <img src="planes/green counter 6.png" class="hud-plane green" alt="" draggable="false">
        <img src="planes/blue counter 6.png" class="hud-plane blue" alt="" draggable="false">
      </div>

      <div id="mantisIndicator" class="turn-indicator" style="display:none;"></div>
      <div id="goatIndicator" class="turn-indicator" style="display:none;"></div>
      <div id="harnessInspectorOverlay" class="inspector-overlay" aria-hidden="true">
        <svg id="inspectorSvg" class="inspector-overlay__svg" viewBox="0 0 460 800" preserveAspectRatio="none">
          <line id="inspectorCrosshairH" class="inspector-overlay__crosshair" x1="0" y1="0" x2="460" y2="0"></line>
          <line id="inspectorCrosshairV" class="inspector-overlay__crosshair" x1="0" y1="0" x2="0" y2="800"></line>
          <line id="inspectorRulerLine" class="inspector-overlay__ruler-line" x1="0" y1="0" x2="0" y2="0"></line>
          <circle id="inspectorPointA" class="inspector-overlay__point" cx="0" cy="0" r="5"></circle>
          <circle id="inspectorPointB" class="inspector-overlay__point" cx="0" cy="0" r="5"></circle>
        </svg>
        <div id="inspectorTooltip" class="inspector-overlay__tooltip" role="status" aria-live="polite">
          <div id="inspectorTooltipContent" class="inspector-overlay__tooltip-content">
            <div class="inspector-overlay__row">
              <strong>Курсор</strong>
              <span id="inspectorCursorText" class="inspector-overlay__value">—</span>
            </div>
            <div class="inspector-overlay__row">
              <strong>Объект</strong>
              <span id="inspectorTargetText" class="inspector-overlay__value">—</span>
            </div>
            <div class="inspector-overlay__row">
              <strong>Линейка</strong>
              <span id="inspectorRulerText" class="inspector-overlay__value">—</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="overlayContainer" aria-hidden="true">
      <canvas id="aimCanvas" style="display:none;"></canvas>
      <canvas id="planeCanvas" style="display:none;"></canvas>
      <div id="fxLayer"></div>
    </div>

    <div id="modeMenu">
      <h1 class="game-title">Paper Wings!</h1>

      <div class="mode-options">
        <button id="hotSeatBtn" class="mode-btn">Hot Seat</button>
        <button id="computerBtn" class="mode-btn">Computer</button>
        <button id="onlineBtn" class="mode-btn" disabled>Online</button>
      </div>

      <button id="playBtn" class="disabled" disabled>Play</button>

      <div class="rules-options">
        <button id="classicRulesBtn" class="rules-btn selected">Classic Rules</button>
        <button id="advancedSettingsBtn" class="rules-btn">Advanced Settings</button>
      </div>
    </div>

    <div id="endGameButtons" style="display:none;">
      <p>Play Again?</p>
      <button id="yesButton" class="end-btn">Yes</button>
      <button id="noButton" class="end-btn">No</button>
    </div>
  </div>

  <aside class="harness-panel harness-panel--right" aria-label="Сценарии и эффекты">
    <h1>Сценарии</h1>

    <div class="harness-section" aria-labelledby="inspectorTitle">
      <h2 id="inspectorTitle">Инспектор поля</h2>
      <div class="harness-button-group">
        <button id="toggleInspectorBtn" class="full-width">Курсор: выкл.</button>
        <button id="toggleRulerBtn" class="full-width" disabled>Линейка: выкл.</button>
      </div>
      <dl class="status-grid inspector-status">
        <div><dt>Курсор</dt><dd id="inspectorCursorPanel">—</dd></div>
        <div><dt>Объект</dt><dd id="inspectorTargetPanel">—</dd></div>
        <div><dt>Точка A</dt><dd id="inspectorPointAPanel">—</dd></div>
        <div><dt>Точка B</dt><dd id="inspectorPointBPanel">—</dd></div>
        <div><dt>Расстояние</dt><dd id="inspectorDistancePanel">—</dd></div>
      </dl>
      <p class="harness-note">Активируйте курсор, чтобы видеть координаты и объект под указателем. Линейка фиксирует две точки и рассчитывает расстояние между ними.</p>
    </div>

    <div class="harness-section" aria-labelledby="stateTitle">
      <h2 id="stateTitle">Состояние</h2>
      <dl class="status-grid">
        <div><dt>Раунд</dt><dd id="statusRound">–</dd></div>
        <div><dt>Фаза</dt><dd id="statusPhase">–</dd></div>
        <div><dt>Ход</dt><dd id="statusTurn">–</dd></div>
        <div><dt>Стрелять?</dt><dd id="statusAwaiting">–</dd></div>
        <div><dt>ПВО</dt><dd id="statusAA">–</dd></div>
        <div><dt>Здания</dt><dd id="statusBuildings">–</dd></div>
      </dl>
      <p class="harness-note">Значения обновляются автоматически каждые 0.5 секунды.</p>
    </div>

    <div class="harness-section" aria-labelledby="scoreTitle">
      <h2 id="scoreTitle">Очки и звёзды</h2>
      <p>Текущие очки: <strong id="scoreGreen">0</strong> — <strong id="scoreBlue">0</strong></p>
      <div class="harness-button-group">
        <button data-score="green:+1">Зелёные +1</button>
        <button data-score="blue:+1">Синие +1</button>
        <button data-score="green:-1">Зелёные −1</button>
        <button data-score="blue:-1">Синие −1</button>
        <button data-score="green:+5">Зелёные +5</button>
        <button data-score="blue:+5">Синие +5</button>
      </div>
      <label for="popupDelta">Дельта поп-апа</label>
      <input id="popupDelta" type="number" value="3" step="1" />
      <label for="popupTarget">Цель счётчика (опция)</label>
      <input id="popupTarget" type="number" placeholder="Авто" />
      <div class="harness-button-group">
        <button id="popupGreenBtn">Поп-ап зелёных</button>
        <button id="popupBlueBtn">Поп-ап синих</button>
      </div>
      <button id="syncStarsBtn" class="full-width">Пересчитать звёзды</button>
    </div>

    <div class="harness-section" aria-labelledby="planesTitle">
      <h2 id="planesTitle">Самолёты</h2>
      <label for="planeSelect">Целевой самолёт</label>
      <select id="planeSelect" aria-describedby="planeInfoNote"></select>
      <p id="planeInfoNote" class="harness-note">Список обновляется после сброса/старта раунда.</p>
      <div class="plane-details" id="planeDetails">
        <p>Нет выбранного самолёта.</p>
      </div>
      <div class="harness-button-group">
        <button id="toggleAliveBtn">Переключить статус</button>
        <button id="ignitePlaneBtn">Поджечь</button>
        <button id="extinguishPlaneBtn">Потушить</button>
        <button id="explodePlaneBtn">Взрыв по позиции</button>
      </div>
      <div class="harness-button-group">
        <button id="scheduleFlameBtn">Пламя после взрыва</button>
        <button id="refreshPlanesBtn">Обновить список</button>
      </div>
    </div>

    <div class="harness-section" aria-labelledby="fxTitle">
      <h2 id="fxTitle">Эффекты</h2>
      <label for="explosionX">X (0..360)</label>
      <input id="explosionX" type="number" value="180" step="10" />
      <label for="explosionY">Y (0..640)</label>
      <input id="explosionY" type="number" value="320" step="10" />
      <div class="harness-button-group">
        <button id="spawnExplosionBtn">Взрыв по координатам</button>
        <button id="randomExplosionBtn">Случайный взрыв</button>
        <button id="clearFxBtn" class="full-width">Очистить эффекты</button>
      </div>
    </div>
  </aside>

  <script src="script.js"></script>
  <script>
    (function(){
      const planeSelect = document.getElementById('planeSelect');
      const planeDetails = document.getElementById('planeDetails');
      const explosionXInput = document.getElementById('explosionX');
      const explosionYInput = document.getElementById('explosionY');
      const gameContainerEl = document.getElementById('gameContainer');
      const statusElements = {
        round: document.getElementById('statusRound'),
        phase: document.getElementById('statusPhase'),
        turn: document.getElementById('statusTurn'),
        awaiting: document.getElementById('statusAwaiting'),
        aa: document.getElementById('statusAA'),
        buildings: document.getElementById('statusBuildings'),
        scoreGreen: document.getElementById('scoreGreen'),
        scoreBlue: document.getElementById('scoreBlue')
      };

      const HARNESS_FIELD_WIDTH = 460;
      const HARNESS_FIELD_HEIGHT = 800;

      const inspectorElements = {
        overlay: document.getElementById('harnessInspectorOverlay'),
        tooltip: document.getElementById('inspectorTooltip'),
        tooltipContent: document.getElementById('inspectorTooltipContent'),
        cursorValue: document.getElementById('inspectorCursorText'),
        targetValue: document.getElementById('inspectorTargetText'),
        rulerValue: document.getElementById('inspectorRulerText'),
        crosshairH: document.getElementById('inspectorCrosshairH'),
        crosshairV: document.getElementById('inspectorCrosshairV'),
        rulerLine: document.getElementById('inspectorRulerLine'),
        pointA: document.getElementById('inspectorPointA'),
        pointB: document.getElementById('inspectorPointB')
      };

      const inspectorPanelElements = {
        cursor: document.getElementById('inspectorCursorPanel'),
        target: document.getElementById('inspectorTargetPanel'),
        pointA: document.getElementById('inspectorPointAPanel'),
        pointB: document.getElementById('inspectorPointBPanel'),
        distance: document.getElementById('inspectorDistancePanel')
      };

      const inspectorButtons = {
        cursor: document.getElementById('toggleInspectorBtn'),
        ruler: document.getElementById('toggleRulerBtn')
      };

      const inspectorState = {
        active: false,
        pointerInside: false,
        rulerActive: false,
        firstPoint: null,
        secondPoint: null,
        lastCursor: null,
        lastTarget: null
      };

      function formatPoint(point){
        if(!point) return '—';
        const x = Number.isFinite(point.baseX) ? Math.round(point.baseX) : null;
        const y = Number.isFinite(point.baseY) ? Math.round(point.baseY) : null;
        if(x === null || y === null){
          return '—';
        }
        return `${x}, ${y}`;
      }

      function formatDistanceValue(a, b){
        if(!a || !b) return null;
        const distance = Math.hypot(a.baseX - b.baseX, a.baseY - b.baseY);
        if(!Number.isFinite(distance)) return null;
        return distance >= 100 ? `${Math.round(distance)} px` : `${distance.toFixed(1)} px`;
      }

      function resetTooltipPosition(){
        if(inspectorElements.tooltip){
          inspectorElements.tooltip.style.transform = 'translate(-9999px, -9999px)';
        }
      }

      function updateInspectorButtons(){
        if(inspectorButtons.cursor){
          inspectorButtons.cursor.textContent = inspectorState.active ? 'Курсор: вкл.' : 'Курсор: выкл.';
        }
        if(inspectorButtons.ruler){
          inspectorButtons.ruler.textContent = inspectorState.rulerActive ? 'Линейка: вкл.' : 'Линейка: выкл.';
          inspectorButtons.ruler.disabled = !inspectorState.active;
        }
      }

      function updateOverlayVisibility(){
        const overlay = inspectorElements.overlay;
        if(!overlay) return;
        const visible = inspectorState.active;
        overlay.style.display = visible ? 'block' : 'none';
        overlay.hidden = !visible;
        overlay.setAttribute('aria-hidden', visible ? 'false' : 'true');
      }

      function updateCursorVisibility(show){
        const display = show ? 'block' : 'none';
        if(inspectorElements.crosshairH){
          inspectorElements.crosshairH.style.display = display;
        }
        if(inspectorElements.crosshairV){
          inspectorElements.crosshairV.style.display = display;
        }
        if(inspectorElements.tooltip){
          inspectorElements.tooltip.style.display = show ? 'block' : 'none';
          if(!show){
            resetTooltipPosition();
          }
        }
      }

      function renderCrosshair(cursorData){
        if(!cursorData) return;
        if(inspectorElements.crosshairH){
          inspectorElements.crosshairH.setAttribute('x1', '0');
          inspectorElements.crosshairH.setAttribute('x2', String(HARNESS_FIELD_WIDTH));
          inspectorElements.crosshairH.setAttribute('y1', String(cursorData.baseY));
          inspectorElements.crosshairH.setAttribute('y2', String(cursorData.baseY));
        }
        if(inspectorElements.crosshairV){
          inspectorElements.crosshairV.setAttribute('x1', String(cursorData.baseX));
          inspectorElements.crosshairV.setAttribute('x2', String(cursorData.baseX));
          inspectorElements.crosshairV.setAttribute('y1', '0');
          inspectorElements.crosshairV.setAttribute('y2', String(HARNESS_FIELD_HEIGHT));
        }
      }

      function updateTooltipContent(cursorData, targetInfo){
        if(inspectorElements.cursorValue){
          inspectorElements.cursorValue.textContent = cursorData ? formatPoint(cursorData) : '—';
        }
        if(inspectorElements.targetValue){
          if(targetInfo){
            const lines = [targetInfo.label];
            if(targetInfo.coordsText){
              lines.push(`@ ${targetInfo.coordsText}`);
            }
            if(targetInfo.sizeText){
              lines.push(targetInfo.sizeText);
            }
            inspectorElements.targetValue.textContent = lines.join('\n');
          } else {
            inspectorElements.targetValue.textContent = '—';
          }
        }
        if(inspectorElements.rulerValue){
          if(inspectorState.rulerActive && inspectorState.firstPoint){
            const parts = [`A: ${formatPoint(inspectorState.firstPoint)}`];
            if(inspectorState.secondPoint){
              parts.push(`B: ${formatPoint(inspectorState.secondPoint)}`);
              const distance = formatDistanceValue(inspectorState.firstPoint, inspectorState.secondPoint);
              if(distance){
                parts.push(`Δ: ${distance}`);
              }
            } else {
              parts.push('Выберите точку B');
            }
            inspectorElements.rulerValue.textContent = parts.join('\n');
          } else if(inspectorState.rulerActive){
            inspectorElements.rulerValue.textContent = 'ЛКМ — точка A';
          } else {
            inspectorElements.rulerValue.textContent = '—';
          }
        }
      }

      function updateTooltipPosition(cursorData, rect){
        if(!cursorData || !rect) return;
        const tooltip = inspectorElements.tooltip;
        const content = inspectorElements.tooltipContent;
        if(!tooltip || !content) return;
        const width = content.offsetWidth || 0;
        const height = content.offsetHeight || 0;
        const offset = 12;
        let x = cursorData.cssX + offset;
        let y = cursorData.cssY + offset;
        const maxX = Math.max(rect.width - width - 4, 0);
        const maxY = Math.max(rect.height - height - 4, 0);
        if(x > maxX){
          x = maxX;
        }
        if(y > maxY){
          y = maxY;
        }
        tooltip.style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px)`;
      }

      function updatePanelData(){
        if(inspectorPanelElements.cursor){
          inspectorPanelElements.cursor.textContent = inspectorState.active && inspectorState.lastCursor ? formatPoint(inspectorState.lastCursor) : '—';
        }
        if(inspectorPanelElements.target){
          if(inspectorState.active && inspectorState.lastTarget){
            const parts = [inspectorState.lastTarget.label];
            if(inspectorState.lastTarget.coordsText){
              parts.push(inspectorState.lastTarget.coordsText);
            }
            if(inspectorState.lastTarget.sizeText){
              parts.push(inspectorState.lastTarget.sizeText);
            }
            inspectorPanelElements.target.textContent = parts.join(' · ');
          } else {
            inspectorPanelElements.target.textContent = '—';
          }
        }
        const pointA = inspectorState.rulerActive ? inspectorState.firstPoint : null;
        const pointB = inspectorState.rulerActive ? inspectorState.secondPoint : null;
        if(inspectorPanelElements.pointA){
          inspectorPanelElements.pointA.textContent = pointA ? formatPoint(pointA) : '—';
        }
        if(inspectorPanelElements.pointB){
          inspectorPanelElements.pointB.textContent = pointB ? formatPoint(pointB) : '—';
        }
        if(inspectorPanelElements.distance){
          const dist = pointA && pointB ? formatDistanceValue(pointA, pointB) : null;
          inspectorPanelElements.distance.textContent = dist || '—';
        }
      }

      function updateMeasurementOverlay(){
        const showA = inspectorState.active && inspectorState.rulerActive && inspectorState.firstPoint;
        if(inspectorElements.pointA){
          inspectorElements.pointA.style.display = showA ? 'block' : 'none';
          if(showA){
            inspectorElements.pointA.setAttribute('cx', String(inspectorState.firstPoint.baseX));
            inspectorElements.pointA.setAttribute('cy', String(inspectorState.firstPoint.baseY));
          }
        }
        const showB = inspectorState.active && inspectorState.rulerActive && inspectorState.secondPoint;
        if(inspectorElements.pointB){
          inspectorElements.pointB.style.display = showB ? 'block' : 'none';
          if(showB){
            inspectorElements.pointB.setAttribute('cx', String(inspectorState.secondPoint.baseX));
            inspectorElements.pointB.setAttribute('cy', String(inspectorState.secondPoint.baseY));
          }
        }
        const showLine = inspectorState.active && inspectorState.rulerActive && inspectorState.firstPoint && inspectorState.secondPoint;
        if(inspectorElements.rulerLine){
          inspectorElements.rulerLine.style.display = showLine ? 'block' : 'none';
          if(showLine){
            inspectorElements.rulerLine.setAttribute('x1', String(inspectorState.firstPoint.baseX));
            inspectorElements.rulerLine.setAttribute('y1', String(inspectorState.firstPoint.baseY));
            inspectorElements.rulerLine.setAttribute('x2', String(inspectorState.secondPoint.baseX));
            inspectorElements.rulerLine.setAttribute('y2', String(inspectorState.secondPoint.baseY));
          }
        }
        updatePanelData();
        updateTooltipContent(inspectorState.lastCursor, inspectorState.lastTarget);
      }

      function resetInspectorReadouts(){
        inspectorState.lastCursor = null;
        inspectorState.lastTarget = null;
        resetTooltipPosition();
        updateTooltipContent(null, null);
      }

      function setInspectorActive(active){
        if(inspectorState.active === active) return;
        inspectorState.active = active;
        if(!active){
          inspectorState.pointerInside = false;
          inspectorState.rulerActive = false;
          inspectorState.firstPoint = null;
          inspectorState.secondPoint = null;
          resetInspectorReadouts();
        }
        updateInspectorButtons();
        updateOverlayVisibility();
        updateCursorVisibility(active && inspectorState.pointerInside);
        updateMeasurementOverlay();
      }

      function setRulerActive(active){
        if(inspectorState.rulerActive === active) return;
        inspectorState.rulerActive = active;
        if(!active){
          inspectorState.firstPoint = null;
          inspectorState.secondPoint = null;
        }
        updateInspectorButtons();
        updateMeasurementOverlay();
      }

      function pickInspectableNode(node, container){
        let current = node;
        while(current && current !== container){
          if(current.dataset && current.dataset.inspectorIgnore === 'true'){
            return null;
          }
          const hasLabel = current.getAttribute?.('data-inspector-name') || current.getAttribute?.('aria-label') || current.id || (current.classList && current.classList.length);
          if(hasLabel){
            break;
          }
          current = current.parentElement;
        }
        if(!current || current === document.body){
          return container;
        }
        return current;
      }

      function buildElementLabel(element){
        if(!element) return '—';
        const explicit = element.getAttribute?.('data-inspector-name');
        if(explicit) return explicit;
        const aria = element.getAttribute?.('aria-label');
        if(aria) return aria;
        if(element.id) return `#${element.id}`;
        if(element.classList && element.classList.length){
          return `${element.tagName.toLowerCase()}.${Array.from(element.classList).join('.')}`;
        }
        return element.tagName ? element.tagName.toLowerCase() : 'элемент';
      }

      function describeTargetAt(clientX, clientY, containerRect){
        if(!gameContainerEl || !containerRect || containerRect.width <= 0 || containerRect.height <= 0) return null;
        const elements = typeof document.elementsFromPoint === 'function' ? document.elementsFromPoint(clientX, clientY) : [];
        const fallback = elements && elements.length ? elements : [document.elementFromPoint(clientX, clientY)].filter(Boolean);
        let target = null;
        for(const el of fallback){
          if(!el) continue;
          if(el === inspectorElements.overlay || el.closest?.('#harnessInspectorOverlay')) continue;
          if(gameContainerEl.contains(el)){
            target = el;
            break;
          }
        }
        if(!target) return null;
        const inspected = pickInspectableNode(target, gameContainerEl);
        if(!inspected) return null;
        const rect = inspected.getBoundingClientRect();
        if(!rect) return null;
        const relativeLeft = rect.left - containerRect.left;
        const relativeTop = rect.top - containerRect.top;
        const baseLeft = clamp(Math.round((relativeLeft / containerRect.width) * HARNESS_FIELD_WIDTH), 0, HARNESS_FIELD_WIDTH);
        const baseTop = clamp(Math.round((relativeTop / containerRect.height) * HARNESS_FIELD_HEIGHT), 0, HARNESS_FIELD_HEIGHT);
        const baseWidth = Math.max(0, Math.round((rect.width / containerRect.width) * HARNESS_FIELD_WIDTH));
        const baseHeight = Math.max(0, Math.round((rect.height / containerRect.height) * HARNESS_FIELD_HEIGHT));
        return {
          element: inspected,
          label: buildElementLabel(inspected),
          coordsText: `${baseLeft}, ${baseTop}`,
          sizeText: `${baseWidth}×${baseHeight}`
        };
      }

      function handlePointerMove(event){
        if(!inspectorState.active || !gameContainerEl) return;
        const rect = gameContainerEl.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        if(width <= 0 || height <= 0) return;
        const cssX = event.clientX - rect.left;
        const cssY = event.clientY - rect.top;
        const inside = cssX >= 0 && cssY >= 0 && cssX <= width && cssY <= height;
        inspectorState.pointerInside = inside;
        updateCursorVisibility(inside);
        if(!inside){
          resetInspectorReadouts();
          updatePanelData();
          return;
        }
        const baseX = clamp(Math.round((cssX / width) * HARNESS_FIELD_WIDTH), 0, HARNESS_FIELD_WIDTH);
        const baseY = clamp(Math.round((cssY / height) * HARNESS_FIELD_HEIGHT), 0, HARNESS_FIELD_HEIGHT);
        const cursorData = { baseX, baseY, cssX, cssY };
        inspectorState.lastCursor = cursorData;
        const targetInfo = describeTargetAt(event.clientX, event.clientY, rect);
        inspectorState.lastTarget = targetInfo;
        renderCrosshair(cursorData);
        updateTooltipContent(cursorData, targetInfo);
        updateTooltipPosition(cursorData, rect);
        updatePanelData();
      }

      function handlePointerLeave(){
        if(!inspectorState.active) return;
        inspectorState.pointerInside = false;
        resetInspectorReadouts();
        updateCursorVisibility(false);
        updatePanelData();
      }

      function handlePointerDown(event){
        if(!inspectorState.active || !inspectorState.rulerActive || !gameContainerEl) return;
        if(event.button !== 0) return;
        const rect = gameContainerEl.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        if(width <= 0 || height <= 0) return;
        const cssX = event.clientX - rect.left;
        const cssY = event.clientY - rect.top;
        if(cssX < 0 || cssY < 0 || cssX > width || cssY > height) return;
        const baseX = clamp(Math.round((cssX / width) * HARNESS_FIELD_WIDTH), 0, HARNESS_FIELD_WIDTH);
        const baseY = clamp(Math.round((cssY / height) * HARNESS_FIELD_HEIGHT), 0, HARNESS_FIELD_HEIGHT);
        const point = { baseX, baseY };
        if(!inspectorState.firstPoint || inspectorState.secondPoint){
          inspectorState.firstPoint = point;
          inspectorState.secondPoint = null;
        } else {
          inspectorState.secondPoint = point;
        }
        updateMeasurementOverlay();
      }

      inspectorButtons.cursor?.addEventListener('click', () => {
        setInspectorActive(!inspectorState.active);
      });

      inspectorButtons.ruler?.addEventListener('click', () => {
        const enable = !inspectorState.rulerActive;
        if(enable && !inspectorState.active){
          setInspectorActive(true);
        }
        setRulerActive(enable);
      });

      gameContainerEl?.addEventListener('pointermove', handlePointerMove);
      gameContainerEl?.addEventListener('pointerleave', handlePointerLeave);
      gameContainerEl?.addEventListener('pointerdown', handlePointerDown);

      updateInspectorButtons();
      updateOverlayVisibility();
      updateCursorVisibility(false);
      resetInspectorReadouts();
      updateMeasurementOverlay();

      function adjustHarnessLayout(){
        const game = gameContainerEl;
        if(!game) return;
        const leftPanel = document.querySelector('.harness-panel--left');
        const rightPanel = document.querySelector('.harness-panel--right');
        const leftWidth = leftPanel ? leftPanel.getBoundingClientRect().width + 24 : 24;
        const rightWidth = rightPanel ? rightPanel.getBoundingClientRect().width + 24 : 24;
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
        const gameRect = game.getBoundingClientRect();
        const gameWidth = gameRect.width || game.offsetWidth || 0;
        const available = viewportWidth - leftWidth - rightWidth;
        if(available > 0 && gameWidth > 0){
          const newLeft = leftWidth + Math.max((available - gameWidth) / 2, 0);
          game.style.left = Math.round(newLeft) + 'px';
        }
      }

      function queueLayout(){
        requestAnimationFrame(adjustHarnessLayout);
      }

      function patchFunction(name, after){
        const original = window[name];
        if(typeof original !== 'function') return;
        window[name] = function patchedFunction(){
          const result = original.apply(this, arguments);
          try {
            after?.();
          } catch(err) {
            console.error('[Harness] Ошибка пост-обработки', err);
          }
          return result;
        };
      }

      function refreshPlaneOptions(){
        if(!planeSelect) return;
        const planes = Array.isArray(window.points) ? window.points : [];
        const previousValue = planeSelect.value;
        planeSelect.innerHTML = '';
        planes.forEach((plane, index) => {
          const option = document.createElement('option');
          const status = plane.isAlive ? 'жив' : 'сбит';
          option.value = String(index);
          option.textContent = `${index + 1}. ${plane.color || '—'} · ${status}`;
          planeSelect.append(option);
        });
        if(planes.length === 0){
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'Нет самолётов';
          planeSelect.append(option);
          planeSelect.disabled = true;
        } else {
          planeSelect.disabled = false;
          if(previousValue && planeSelect.querySelector(`option[value="${previousValue}"]`)){
            planeSelect.value = previousValue;
          } else {
            planeSelect.selectedIndex = 0;
          }
        }
        updatePlaneDetails();
      }

      function formatNumber(value){
        return Number.isFinite(value) ? Math.round(value) : '—';
      }

      function getSelectedPlane(){
        if(!planeSelect || planeSelect.disabled) return null;
        const index = parseInt(planeSelect.value, 10);
        const planes = Array.isArray(window.points) ? window.points : [];
        if(Number.isInteger(index) && index >= 0 && index < planes.length){
          return planes[index];
        }
        return null;
      }

      function updatePlaneDetails(){
        const plane = getSelectedPlane();
        if(!plane){
          planeDetails.innerHTML = '<p>Нет выбранного самолёта.</p>';
          return;
        }
        const lines = [
          `<p><strong>Цвет:</strong> ${plane.color || 'неизвестно'}</p>`,
          `<p><strong>Координаты:</strong> ${formatNumber(plane.x)}, ${formatNumber(plane.y)}</p>`,
          `<p><strong>Статус:</strong> ${plane.isAlive ? 'в строю' : 'сбит'}</p>`,
          `<p><strong>Горит:</strong> ${plane.burning ? 'да' : 'нет'}</p>`
        ];
        if(plane.flagColor){
          lines.push(`<p><strong>Флаг:</strong> ${plane.flagColor}</p>`);
        }
        planeDetails.innerHTML = lines.join('');
      }

      function parseCoord(input, fallback){
        if(!input) return fallback;
        const value = parseFloat(input.value);
        return Number.isFinite(value) ? value : fallback;
      }

      function clamp(value, min, max){
        if(!Number.isFinite(value)) return value;
        return Math.min(Math.max(value, min), max);
      }

      function spawnExplosionAt(x, y){
        if(typeof window.spawnExplosion !== 'function') return;
        const canvas = document.getElementById('gameCanvas');
        const width = canvas?.width || 360;
        const height = canvas?.height || 640;
        const clampedX = clamp(x, 0, width);
        const clampedY = clamp(y, 0, height);
        window.spawnExplosion(clampedX, clampedY);
      }

      function ignitePlane(plane){
        if(!plane) return;
        plane.burning = true;
        plane.flameFxDisabled = false;
        if(typeof window.spawnBurningFlameFx === 'function'){
          window.spawnBurningFlameFx(plane);
        }
      }

      function extinguishPlane(plane){
        if(!plane) return;
        plane.burning = false;
        if(typeof window.ensurePlaneFlameFx === 'function'){
          window.ensurePlaneFlameFx(plane);
        }
      }

      function updateScores(){
        if(statusElements.scoreGreen){
          statusElements.scoreGreen.textContent = Number.isFinite(window.greenScore) ? window.greenScore : '—';
        }
        if(statusElements.scoreBlue){
          statusElements.scoreBlue.textContent = Number.isFinite(window.blueScore) ? window.blueScore : '—';
        }
      }

      function updateStatus(){
        if(statusElements.round){
          statusElements.round.textContent = Number.isFinite(window.roundNumber) ? window.roundNumber : '—';
        }
        if(statusElements.phase){
          statusElements.phase.textContent = window.phase || '—';
        }
        if(statusElements.turn){
          const colors = Array.isArray(window.turnColors) ? window.turnColors : [];
          const idx = Number.isInteger(window.turnIndex) ? window.turnIndex : 0;
          statusElements.turn.textContent = colors.length ? colors[idx % colors.length] : '—';
        }
        if(statusElements.awaiting){
          statusElements.awaiting.textContent = window.awaitingFlightResolution ? 'да' : 'нет';
        }
        if(statusElements.aa){
          statusElements.aa.textContent = window.settings?.addAA ? 'включено' : 'выключено';
        }
        if(statusElements.buildings){
          const count = Array.isArray(window.buildings) ? window.buildings.length : 0;
          statusElements.buildings.textContent = count;
        }
        const aaBtn = document.getElementById('toggleAAButton');
        if(aaBtn){
          aaBtn.textContent = window.settings?.addAA ? 'ПВО: вкл.' : 'ПВО: выкл.';
        }
        const edgesBtn = document.getElementById('toggleEdgesButton');
        if(edgesBtn){
          edgesBtn.textContent = window.settings?.sharpEdges ? 'Контуры: вкл.' : 'Контуры: выкл.';
        }
        updateScores();
      }

      function queueStatusUpdate(){
        requestAnimationFrame(updateStatus);
      }

      function resolveSimulatedWinnerColor(){
        const greenScoreValue = Number.isFinite(window.greenScore) ? window.greenScore : 0;
        const blueScoreValue = Number.isFinite(window.blueScore) ? window.blueScore : 0;
        if(greenScoreValue > blueScoreValue){
          return 'green';
        }
        if(blueScoreValue > greenScoreValue){
          return 'blue';
        }
        const colors = Array.isArray(window.turnColors) ? window.turnColors : [];
        const index = Number.isInteger(window.turnIndex) ? window.turnIndex : 0;
        const fallback = colors.length ? colors[index % colors.length] : null;
        return fallback === 'blue' ? 'blue' : 'green';
      }

      function lockInSimulatedWinner(options){
        const winnerColor = resolveSimulatedWinnerColor();
        window.lockInWinner?.(winnerColor, options);
        queueStatusUpdate();
      }

      function defaultExplosionInputs(){
        const canvas = document.getElementById('gameCanvas');
        const width = canvas?.width || 360;
        const height = canvas?.height || 640;
        if(explosionXInput && !explosionXInput.dataset.locked){
          explosionXInput.value = String(Math.round(width / 2));
        }
        if(explosionYInput && !explosionYInput.dataset.locked){
          explosionYInput.value = String(Math.round(height / 2));
        }
      }

      patchFunction('resetGame', () => {
        refreshPlaneOptions();
        queueStatusUpdate();
        queueLayout();
      });

      patchFunction('startNewRound', () => {
        refreshPlaneOptions();
        queueStatusUpdate();
        queueLayout();
      });

      patchFunction('resizeCanvas', () => {
        queueLayout();
        defaultExplosionInputs();
      });

      document.getElementById('resetGameBtn')?.addEventListener('click', () => {
        window.resetGame?.();
      });

      document.getElementById('startRoundBtn')?.addEventListener('click', () => {
        window.startNewRound?.();
      });

      document.getElementById('startLoopBtn')?.addEventListener('click', () => {
        window.startGameLoop?.();
      });

      document.getElementById('stopLoopBtn')?.addEventListener('click', () => {
        window.stopGameLoop?.();
      });

      document.getElementById('showMenuBtn')?.addEventListener('click', () => {
        const menu = document.getElementById('modeMenu');
        if(menu) menu.style.display = 'block';
      });

      document.getElementById('hideMenuBtn')?.addEventListener('click', () => {
        const menu = document.getElementById('modeMenu');
        if(menu) menu.style.display = 'none';
      });

      document.getElementById('forceGreenWinBtn')?.addEventListener('click', () => {
        window.lockInWinner?.('green', { showEndScreen: true });
        queueStatusUpdate();
      });

      document.getElementById('forceBlueWinBtn')?.addEventListener('click', () => {
        window.lockInWinner?.('blue', { showEndScreen: true });
        queueStatusUpdate();
      });

      document.getElementById('lockRoundWinBtn')?.addEventListener('click', () => {
        lockInSimulatedWinner({ showEndScreen: false });
      });

      document.getElementById('lockGameWinBtn')?.addEventListener('click', () => {
        lockInSimulatedWinner({ showEndScreen: true });
      });

      document.getElementById('showEndScreenBtn')?.addEventListener('click', () => {
        const panel = document.getElementById('endGameButtons');
        if(panel) panel.style.display = 'block';
      });

      document.getElementById('hideEndScreenBtn')?.addEventListener('click', () => {
        const panel = document.getElementById('endGameButtons');
        if(panel) panel.style.display = 'none';
      });

      document.getElementById('toggleAAButton')?.addEventListener('click', (event) => {
        if(window.settings){
          window.settings.addAA = !window.settings.addAA;
        }
        queueStatusUpdate();
        window.startNewRound?.();
        if(event?.currentTarget){
          event.currentTarget.textContent = window.settings?.addAA ? 'ПВО: вкл.' : 'ПВО: выкл.';
        }
      });

      document.getElementById('toggleEdgesButton')?.addEventListener('click', (event) => {
        if(window.settings){
          window.settings.sharpEdges = !window.settings.sharpEdges;
        }
        queueStatusUpdate();
        window.startNewRound?.();
        if(event?.currentTarget){
          event.currentTarget.textContent = window.settings?.sharpEdges ? 'Контуры: вкл.' : 'Контуры: выкл.';
        }
      });

      document.getElementById('nextMapButton')?.addEventListener('click', () => {
        if(window.settings){
          const mapCount = 3; // обновите при добавлении новых карт
          const current = Number.isInteger(window.settings.mapIndex) ? window.settings.mapIndex : 0;
          window.settings.mapIndex = (current + 1) % mapCount;
        }
        window.startNewRound?.();
        queueStatusUpdate();
      });

      document.querySelectorAll('[data-score]')?.forEach(button => {
        button.addEventListener('click', () => {
          const value = button.dataset.score || '';
          const [color, delta] = value.split(':');
          const amount = parseInt(delta, 10);
          if(color && Number.isFinite(amount)){
            window.addScore?.(color, amount);
            queueStatusUpdate();
          }
        });
      });

      document.getElementById('popupGreenBtn')?.addEventListener('click', () => {
        const delta = parseInt(document.getElementById('popupDelta')?.value, 10) || 0;
        const targetInput = document.getElementById('popupTarget');
        const target = targetInput && targetInput.value !== '' ? parseInt(targetInput.value, 10) : (Number.isFinite(window.greenScore) ? window.greenScore + delta : delta);
        window.spawnScorePopup?.('green', delta, target);
      });

      document.getElementById('popupBlueBtn')?.addEventListener('click', () => {
        const delta = parseInt(document.getElementById('popupDelta')?.value, 10) || 0;
        const targetInput = document.getElementById('popupTarget');
        const target = targetInput && targetInput.value !== '' ? parseInt(targetInput.value, 10) : (Number.isFinite(window.blueScore) ? window.blueScore + delta : delta);
        window.spawnScorePopup?.('blue', delta, target);
      });

      document.getElementById('syncStarsBtn')?.addEventListener('click', () => {
        window.syncAllStarStates?.();
        window.renderScoreboard?.();
      });

      document.getElementById('toggleAliveBtn')?.addEventListener('click', () => {
        const plane = getSelectedPlane();
        if(!plane) return;
        plane.isAlive = !plane.isAlive;
        updatePlaneDetails();
      });

      document.getElementById('ignitePlaneBtn')?.addEventListener('click', () => {
        const plane = getSelectedPlane();
        ignitePlane(plane);
        updatePlaneDetails();
      });

      document.getElementById('extinguishPlaneBtn')?.addEventListener('click', () => {
        const plane = getSelectedPlane();
        extinguishPlane(plane);
        updatePlaneDetails();
      });

      document.getElementById('explodePlaneBtn')?.addEventListener('click', () => {
        const plane = getSelectedPlane();
        if(!plane) return;
        window.spawnExplosion?.(plane.x, plane.y, plane.color || null);
        updatePlaneDetails();
      });

      document.getElementById('scheduleFlameBtn')?.addEventListener('click', () => {
        const plane = getSelectedPlane();
        if(!plane) return;
        plane.burning = true;
        if(typeof window.schedulePlaneFlameFx === 'function'){
          window.schedulePlaneFlameFx(plane);
        }
        updatePlaneDetails();
      });

      document.getElementById('refreshPlanesBtn')?.addEventListener('click', () => {
        refreshPlaneOptions();
      });

      document.getElementById('spawnExplosionBtn')?.addEventListener('click', () => {
        const x = parseCoord(explosionXInput, 180);
        const y = parseCoord(explosionYInput, 320);
        spawnExplosionAt(x, y);
      });

      document.getElementById('randomExplosionBtn')?.addEventListener('click', () => {
        const canvas = document.getElementById('gameCanvas');
        const width = canvas?.width || 360;
        const height = canvas?.height || 640;
        const x = Math.random() * width;
        const y = Math.random() * height;
        spawnExplosionAt(x, y);
      });

      document.getElementById('clearFxBtn')?.addEventListener('click', () => {
        if(typeof window.cleanupBurningFx === 'function'){
          window.cleanupBurningFx();
        }
        const fxLayer = document.getElementById('fxLayer');
        if(fxLayer){
          fxLayer.innerHTML = '';
        }
      });

      explosionXInput?.addEventListener('input', () => {
        explosionXInput.dataset.locked = 'true';
      });

      explosionYInput?.addEventListener('input', () => {
        explosionYInput.dataset.locked = 'true';
      });

      planeSelect?.addEventListener('change', updatePlaneDetails);

      window.addEventListener('resize', queueLayout);

      setInterval(updateStatus, 500);

      refreshPlaneOptions();
      updateStatus();
      defaultExplosionInputs();
      queueLayout();
    })();
  </script>
</body>
</html>
